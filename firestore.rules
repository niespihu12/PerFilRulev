/**
 * @fileoverview Firestore Security Rules for PerFinRule application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model. Users can only access their own profile data and the transactions associated with their user ID.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. The userId must match the Firebase Auth UID.
 * - /users/{userId}/transactions/{transactionId}: Stores transaction data for each user.
 *
 * Key Security Decisions:
 * - Users can only create, read, update, and delete their own transactions.
 * - User listing is disallowed to prevent information disclosure.
 *
 * Denormalization for Authorization:
 *   - The userId field in the Transaction document duplicates the path-based ownership. This ensures data consistency and allows for future flexibility if the data structure changes.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profile data. Only the user with the matching UID can read or write their own profile.
     * @path /users/{userId}
     * @allow (create) User 'user_abc' with matching UID creates their profile.
     *   request.auth.uid == 'user_abc' and request.resource.data.id == 'user_abc'
     * @allow (get, update, delete) User 'user_abc' reads/updates/deletes their own profile.
     *   request.auth.uid == 'user_abc' and resource.data.id == 'user_abc'
     * @deny (create) User 'user_abc' attempts to create a profile for another user 'user_xyz'.
     *   request.auth.uid == 'user_abc' and request.resource.data.id == 'user_xyz'
     * @deny (get, update, delete) User 'user_abc' attempts to read/update/delete another user 'user_xyz' profile.
     *   request.auth.uid == 'user_abc' and resource.data.id == 'user_xyz'
     * @principle Enforces strict user-ownership and relational integrity for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource.data.id == userId;
      allow delete: if isOwner(userId) && resource.data.id == userId;
    }

    /**
     * @description Protects transaction data for each user. Only the owning user can create, read, update, and delete transactions under their user ID.
     * @path /users/{userId}/transactions/{transactionId}
     * @allow (create) User 'user_abc' creates a transaction under their user ID.
     *   request.auth.uid == 'user_abc' and request.resource.data.userId == 'user_abc'
     * @allow (get, update, delete) User 'user_abc' reads/updates/deletes a transaction under their user ID.
     *   request.auth.uid == 'user_abc' and resource.data.userId == 'user_abc'
     * @allow (list) User 'user_abc' lists transactions under their user ID.
     *   request.auth.uid == 'user_abc'
     * @deny (create) User 'user_abc' attempts to create a transaction for another user 'user_xyz'.
     *   request.auth.uid == 'user_abc' and request.resource.data.userId == 'user_xyz'
     * @deny (get, update, delete) User 'user_abc' attempts to read/update/delete a transaction for another user 'user_xyz'.
     *   request.auth.uid == 'user_abc' and resource.data.userId == 'user_xyz'
     * @principle Enforces strict user-ownership for transactions and relational integrity between user and transaction data.
     */
    match /users/{userId}/transactions/{transactionId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
    }
  }
}